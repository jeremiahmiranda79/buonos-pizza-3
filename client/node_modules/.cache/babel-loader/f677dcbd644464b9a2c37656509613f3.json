{"ast":null,"code":"import { parentEntrySlot } from \"./context.js\";\nimport { hasOwnProperty, maybeUnsubscribe, arrayFromSet } from \"./helpers.js\";\nvar EntryMethods = {\n  setDirty: true,\n  dispose: true,\n  forget: true // Fully remove parent Entry from LRU cache and computation graph\n};\n\nexport function dep(options) {\n  var depsByKey = new Map();\n  var subscribe = options && options.subscribe;\n  function depend(key) {\n    var parent = parentEntrySlot.getValue();\n    if (parent) {\n      var _dep = depsByKey.get(key);\n      if (!_dep) {\n        depsByKey.set(key, _dep = new Set());\n      }\n      parent.dependOn(_dep);\n      if (typeof subscribe === \"function\") {\n        maybeUnsubscribe(_dep);\n        _dep.unsubscribe = subscribe(key);\n      }\n    }\n  }\n  depend.dirty = function dirty(key, entryMethodName) {\n    var dep = depsByKey.get(key);\n    if (dep) {\n      var m = entryMethodName && hasOwnProperty.call(EntryMethods, entryMethodName) ? entryMethodName : \"setDirty\";\n      // We have to use arrayFromSet(dep).forEach instead of dep.forEach,\n      // because modifying a Set while iterating over it can cause elements in\n      // the Set to be removed from the Set before they've been iterated over.\n      arrayFromSet(dep).forEach(function (entry) {\n        return entry[m]();\n      });\n      depsByKey.delete(key);\n      maybeUnsubscribe(dep);\n    }\n  };\n  return depend;\n}","map":null,"metadata":{},"sourceType":"module"}