{"ast":null,"code":"import { visit } from '../language/visitor';\n\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var fragments = Object.create(null);\n  var positions = new Map();\n  var depGraph = Object.create(null);\n  var fromName;\n  var idx = 0; // Populate metadata and build a dependency graph.\n\n  visit(documentAST, {\n    OperationDefinition: function OperationDefinition(node) {\n      fromName = opName(node);\n      operations.push(node);\n      positions.set(node, idx++);\n    },\n    FragmentDefinition: function FragmentDefinition(node) {\n      fromName = node.name.value;\n      fragments[fromName] = node;\n      positions.set(node, idx++);\n    },\n    FragmentSpread: function FragmentSpread(node) {\n      var toName = node.name.value;\n      (depGraph[fromName] || (depGraph[fromName] = Object.create(null)))[toName] = true;\n    }\n  }); // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  var separatedDocumentASTs = Object.create(null);\n  for (var _i2 = 0; _i2 < operations.length; _i2++) {\n    var operation = operations[_i2];\n    var operationName = opName(operation);\n    var dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName); // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    var definitions = [operation];\n    for (var _i4 = 0, _Object$keys2 = Object.keys(dependencies); _i4 < _Object$keys2.length; _i4++) {\n      var name = _Object$keys2[_i4];\n      definitions.push(fragments[name]);\n    }\n    definitions.sort(function (n1, n2) {\n      return (positions.get(n1) || 0) - (positions.get(n2) || 0);\n    });\n    separatedDocumentASTs[operationName] = {\n      kind: 'Document',\n      definitions: definitions\n    };\n  }\n  return separatedDocumentASTs;\n}\n\n// Provides the empty string for anonymous operations.\nfunction opName(operation) {\n  return operation.name ? operation.name.value : '';\n} // From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\n\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  var immediateDeps = depGraph[fromName];\n  if (immediateDeps) {\n    for (var _i6 = 0, _Object$keys4 = Object.keys(immediateDeps); _i6 < _Object$keys4.length; _i6++) {\n      var toName = _Object$keys4[_i6];\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}