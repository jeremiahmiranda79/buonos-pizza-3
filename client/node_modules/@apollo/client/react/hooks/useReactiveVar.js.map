{"version":3,"file":"useReactiveVar.js","sourceRoot":"","sources":["../../../src/react/hooks/useReactiveVar.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAG/B,MAAM,UAAU,cAAc,CAAI,EAAkB;IAClD,IAAM,KAAK,GAAG,EAAE,EAAE,CAAC;IAInB,IAAM,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAK1C,KAAK,CAAC,SAAS,CAAC;QACd,IAAM,iBAAiB,GAAG,EAAE,EAAE,CAAC;QAC/B,IAAI,KAAK,KAAK,iBAAiB,EAAE;YAG/B,QAAQ,CAAC,iBAAiB,CAAC,CAAC;SAC7B;aAAM;YACL,OAAO,EAAE,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;SAClC;IACH,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;IAEZ,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["import * as React from \"react\";\nimport type { ReactiveVar } from \"../../core/index.js\";\n\nexport function useReactiveVar<T>(rv: ReactiveVar<T>): T {\n  const value = rv();\n\n  // We don't actually care what useState thinks the value of the variable\n  // is, so we take only the update function from the returned array.\n  const setValue = React.useState(value)[1];\n\n  // We subscribe to variable updates on initial mount and when the value has\n  // changed. This avoids a subtle bug in React.StrictMode where multiple\n  // listeners are added, leading to inconsistent updates.\n  React.useEffect(() => {\n    const probablySameValue = rv();\n    if (value !== probablySameValue) {\n      // If the value of rv has already changed, we don't need to listen for the\n      // next change, because we can report this change immediately.\n      setValue(probablySameValue);\n    } else {\n      return rv.onNextChange(setValue);\n    }\n  }, [value]);\n\n  return value;\n}\n"]}